import{_ as i,a as c,b as l}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.61fdc39d.js";import{_}from"./chunks/CustomLink.cd661532.js";import{_ as p,o as d,c as h,H as o,k as t,a as e}from"./chunks/framework.926cbeec.js";import"./chunks/commonjsHelpers.725317a4.js";const q=JSON.parse('{"title":"类型系统","description":"","frontmatter":{},"headers":[],"relativePath":"ts/ch3.md","filePath":"ts/ch3.md","lastUpdated":1696923443000}'),m={name:"ts/ch3.md"},u=t("h1",{id:"类型系统",tabindex:"-1"},[e("类型系统 "),t("a",{class:"header-anchor",href:"#类型系统","aria-label":'Permalink to "类型系统"'},"​")],-1),f=t("h2",{id:"函数类型",tabindex:"-1"},[e("函数类型 "),t("a",{class:"header-anchor",href:"#函数类型","aria-label":'Permalink to "函数类型"'},"​")],-1),b=t("p",null,"如何对两个函数类型进行兼容性比较？",-1),g=t("p",null,"即比较它们的参数类型是否是反向的父子类型关系，返回值是否是正向的父子类型关系。",-1),k=t("blockquote",null,[t("p",null,"也就是判断参数类型是否遵循类型逆变，返回值类型是否遵循类型协变。")],-1),y=t("p",null,[e("我们可以通过 TypeScript ESLint 的规则以及 "),t("code",null,"strictFunctionTypes"),e(" 配置，来为 interface 内的函数声明启用严格的检查模式。")],-1),x=t("h2",{id:"contributors",tabindex:"-1"},[e("Contributors "),t("a",{class:"header-anchor",href:"#contributors","aria-label":'Permalink to "Contributors"'},"​")],-1);function $(P,C,S,T,N,B){const s=i,n=_,a=c,r=l;return d(),h("div",null,[u,o(s,{readTime:"1",words:"176"}),f,b,g,k,y,t("p",null,[e("如果项目内配置了 TypeScript ESLint，可以加上 "),o(n,{title:"method-signature-style",href:"https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md"}),e(" 这条规则提升代码质量。")]),x,o(a),o(r)])}const w=p(m,[["render",$]]);export{q as __pageData,w as default};
